---
title: MIT 6.S081 Operarting System Engineering
date: 2023-01-20 11:45:02
tags:
  - CS
password: skqliiiao
abstract: MIT 6.S081 labs solution
---

## [Lab util: Unix utilities](https://pdos.csail.mit.edu/6.828/2021/labs/util.html)

完成于 2023/01/14

### sleep

实现睡眠，直接调用系统函数。

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(2, "usage: sleep time");
        exit(1);
    }
    sleep(atoi(argv[1]));
    exit(0);
}
```

### pingpong

学习使用pipe来传递信息。

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int main(int argc, char *argv[]) {
    int p[2];
    char buf[2];
    pipe(p);
    if (fork() == 0) {
		if (read(p[0], buf, 1) != 1) {
			fprintf(2, "failed to read in child\n");
			exit(1);
		}
		close(p[0]);
		printf("%d: received ping\n", getpid());
		if (write(p[1], buf, 1) != 1) {
			fprintf(2, "failed to write in child\n");
			exit(1);
		}
		close(p[1]);
	} else {
		if (write(p[1], "a", 1) != 1) {
			fprintf(2, "failed to write in parent\n");
			exit(1);
		}
		close(p[1]);
		wait(0);
		if (read(p[0], buf, 1) != 1) {
			fprintf(2, "failed to read in parent\n");
			exit(1);
		}
		printf("%d: received pong\n", getpid());
		close(p[0]);
	}
    exit(0);
}
```

### primes

这个比较有意思，是要实现一个素数筛。

最开始我写了一个代码能过grader，看了别人的题解才发现自己完全理解错了。

这个多线程筛素数的原理其实很simple，不过需要用pipe来实现比较新鲜。

先选出所有不是2的倍数3,5,7,9…。此时最小值为3。再从中选出所有不是3的倍数5,7,11,…。此时最小值为5，再从中选出所有不是5的倍数7,11,13…。依次类推。当一个数同时不是所有比它小的素数的倍数时，它就一定是素数。

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

void run(int p[]) {
    int prime;
    close(p[1]);
    read(p[0], &prime, 4);
    printf("prime %d\n", prime);
    int n;
    if (read(p[0], &n, 4) == 4) {
        int newp[2];
        pipe(newp);
        if (fork() == 0) {
            run(newp);
        } else {
            close(newp[0]);
            do {
                if (n % prime) {
                    write(newp[1], &n, 4);
                }
            } while (read(p[0], &n, 4) == 4);
            close(p[0]);
            close(newp[1]);
            wait(0);
        }
    }
}

int main(int argc, char *argv[]) {
    int p[2];
    pipe(p);
    if (fork() == 0) {
        run(p);
    } else {
        close(p[0]);
        for (int i = 2; i <= 35; ++i) {
            write(p[1], &i, 4);
        }
        close(p[1]);
        wait(0);
    }
    exit(0);
}
```

### find 

实现一个简单的find，找到当前路径下（包括子目录）文件名为指定字符串的所有文件。

根据提示，学习`ls.c`中是如何读取文件信息，然后递归下去即可。

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/fs.h"

const char *fmtname(const char *path) {
    static char buf[DIRSIZ + 1];
    const char *p;

    // Find first character after last slash.
    for (p = path + strlen(path); p >= path && *p != '/'; p--)
        ;
    p++;

    // Return blank-padded name.
    if (strlen(p) >= DIRSIZ) return p;
    memmove(buf, p, strlen(p));
    memset(buf + strlen(p), ' ', DIRSIZ - strlen(p));
    return buf;
}

void find(const char *path, const char *name) {
    char buf[512], *p;
    int fd;
    struct dirent de;
    struct stat st;

    if ((fd = open(path, 0)) < 0) {
        fprintf(2, "ls: cannot open %s\n", path);
        exit(1);
        return;
    }

    if (fstat(fd, &st) < 0) {
        fprintf(2, "ls: cannot stat %s\n", path);
        close(fd);
        exit(1);
        return;
    }
    if (strlen(path) + 1 + DIRSIZ + 1 > sizeof buf) {
        fprintf(2, "ls: path too long\n");
        exit(1);
    }
    strcpy(buf, path);
    p = buf + strlen(buf);
    *p++ = '/';
    while (read(fd, &de, sizeof(de)) == sizeof(de)) {
        if (de.inum == 0) continue;
        if (strcmp(de.name, ".") == 0) continue;
        if (strcmp(de.name, "..") == 0) continue;
        memmove(p, de.name, DIRSIZ);
        p[DIRSIZ] = 0;
        if (stat(buf, &st) < 0) {
            printf("ls: cannot stat %s\n", buf);
            continue;
        }
        if (st.type == T_DIR) {
            find(buf, name);
        } else if (strcmp(de.name, name) == 0) {
            printf("%s\n", buf);
        }
    }
    close(fd);
}
int main(int argc, char const *argv[]) {
    if (argc != 3) {
        fprintf(2, "Usage: find dir file\n");
        exit(1);
    }
    find(argv[1], argv[2]);
    exit(0);
}
```

### xargs 

不知道为啥放到最后一个。。

就是不停地从上一次exec的输出流中读入结果作为新的参数，插入到当前argv的末尾。。

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/param.h"

int main(int argc, char **argv) {
    if (argc <= 1) {
        fprintf(2, "Usage: xargs command (arg ...)\n");
        exit(1);
    }
    char *command = malloc(strlen(argv[1]) + 1);
    memmove(command, argv[1], strlen(argv[1]));
    char *new_argv[MAXARG];
    new_argv[0] = (char *)malloc(1024 + 1);
    for (int i = 2; i < argc; ++i) {
        new_argv[i - 1] = (char *)malloc(strlen(argv[i]) + 1);
        memmove(new_argv[i - 1], argv[i], strlen(argv[i]));
    }

    new_argv[argc - 1] = (char *)malloc(1024 + 1);

    while (1) {
        char *p = new_argv[argc - 1];
        while (read(0, p, 1)) {
            if (*p == '\n') {
                *p = 0;
                break;
            } else
                p++;
        }
        if (p == new_argv[argc - 1]) break;
        if (fork() == 0) {
            exec(command, new_argv);
        }
        wait(0);
    }
    exit(0);
}
```

## [Lab syscall: System calls](https://pdos.csail.mit.edu/6.828/2021/labs/syscall.html)

### System call tracing

实现`trace`，用来追踪输出此次命令所涉及到的指定系统指令（用二进制串表示）。

首先是在proc中新增一个变量`tracemask`，来记录需要此次需要追踪的指令集合，此变量需要在`fork()`时给子进程继承。

在`syspro.c` 中增加`sys_trace` 函数，将`tracemask`赋值给当前进程：

```c
int sys_trace(void) {
    int tracemask;
    if (argint(0, &tracemask) < 0) return -1;
    myproc()->tracemask = tracemask;
    return 0;
}
```

然后在`syscall.c`中增加输出：

```c
char *trace_name[] = {"fork",  "exit",   "wait",  "pipe",  "read",   "kill",
                      "exec",  "fstat",  "chdir", "dup",   "getpid", "sbrk",
                      "sleep", "uptime", "open",  "write", "mknod",  "unlink",
                      "link",  "mkdir",  "close", "trace", "sysinfo"};
void syscall(void) {
    int num;
    struct proc *p = myproc();
    num = p->trapframe->a7;
    if (num > 0 && num < NELEM(syscalls) && syscalls[num]) {
        p->trapframe->a0 = syscalls[num]();
        if ((1 << num) & p->tracemask) {
            printf("%d: syscall %s -> %d\n", p->pid, trace_name[num - 1],
                   p->trapframe->a0);
        }
    } else {
        printf("%d %s: unknown sys call %d\n", p->pid, p->name, num);
        p->trapframe->a0 = -1;
    }
}
```

### Sysinfo 

读取`sysinfo`中的`freemem`和`nproc`来获取当前剩余内存和未使用线程数。

在`kalloc.c`中，仿照其中函数增加获取空余内存的函数：

```c
uint64 getfreemem(void) {
    struct run *r;

    acquire(&kmem.lock);
    r = kmem.freelist;
    uint64 freemem = 0;
    while (r) {
        r = r->next;
        freemem += PGSIZE;
    }
    release(&kmem.lock);
    return freemem;
}
```

在`proc.c`中，仿照其中函数增加或获取空限线程数的函数：

```c
uint64 getusedproc(void) {
    struct proc *p;
    uint64 count = 0;
    for (p = proc; p < &proc[NPROC]; p++) {
        acquire(&p->lock);
        if (p->state != UNUSED) {
            count++;
        }
        release(&p->lock);
    }
    return count;
}
```

最后在`sysproc.h`中增加该系统函数：

```c
int sys_sysinfo(void) {
    uint64 addr; // user pointer to struct stat

    if (argaddr(0, &addr) < 0) return -1;
    struct proc *p = myproc();
    struct sysinfo info;
    info.freemem = getfreemem();
    info.nproc = getusedproc();
    if (copyout(p->pagetable, addr, (char *)&info, sizeof(info)) < 0) return -1;
    return 0;
}
```

##  [Lab pgtbl: Page tables](https://pdos.csail.mit.edu/6.828/2021/labs/pgtbl.html)

### Speed up system calls

在`proc`中增加一个`usyscall`来存储PID。

基本就是模仿`trapframe`的初始化和销毁操作来补充`usyscall`的代码。

```c
// free a proc structure and the data hanging from it,
// including user pages.
// p->lock must be held.
static void freeproc(struct proc *p) {
  if (p->trapframe)
    kfree((void *)p->trapframe);
  p->trapframe = 0;
  if (p->usyscall)
    kfree((void *)p->usyscall);
  p->usyscall = 0;
  if (p->pagetable)
    proc_freepagetable(p->pagetable, p->sz);
  p->pagetable = 0;
  // some code
}
```

```c
pagetable_t proc_pagetable(struct proc *p) {
  // some code
    
  // map the trapframe just below TRAMPOLINE, for trampoline.S.
  if (mappages(pagetable, TRAPFRAME, PGSIZE, (uint64)(p->trapframe),
               PTE_R | PTE_W) < 0) {
    uvmunmap(pagetable, TRAMPOLINE, 1, 0);
    uvmfree(pagetable, 0);
    return 0;
  }

  if (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p->usyscall),
               PTE_R | PTE_U) < 0) { // USER & READ
    uvmunmap(pagetable, TRAPFRAME, 1, 0);
    uvmunmap(pagetable, TRAMPOLINE, 1, 0);
    uvmfree(pagetable, 0);
    return 0;
  }

  return pagetable;
}
```

```c
// Free a process's page table, and free the
// physical memory it refers to.
void proc_freepagetable(pagetable_t pagetable, uint64 sz) {
  uvmunmap(pagetable, USYSCALL, 1, 0);
  uvmunmap(pagetable, TRAMPOLINE, 1, 0);
  uvmunmap(pagetable, TRAPFRAME, 1, 0);
  uvmfree(pagetable, sz);
}
```

如果用clang-format的话千万记得关掉`SortIncludes`。头文件之间是有依赖关系的，它直接给搞乱了，就会CE。。

### Print a page table

打印当前`pagetable`的三层结构中已使用的部分。

这个挺简单的，模仿`kernal/vm.c` 中的 `freewalk`就行。

```c
void vmprint(pagetable_t pagetable, int level) {
  if (level == 2)
    printf("page table %p\n", pagetable);
  for (int i = 0; i < 512; i++) {
    pte_t pte = pagetable[i];
    if (pte & PTE_V) {
      // this PTE points to a lower-level page table.
      uint64 child = PTE2PA(pte);
      for (int j = 2; j >= level; --j)
        printf(" ..");
      printf("%d: pte %p pa %p\n", i, pte, child);
      if (level > 0)
        vmprint((pagetable_t)child, level - 1);
    }
  }
}
```

### Detecting which pages have been accessed

通过读取`PTE_A`，判断以给定VA为首地址的若干个页面中，有多少个被pagetable访问了，并将结果以二进制串的方式传到某个地址。

由于硬件会自动设置`PTE_A`，因此我们只需要先`walk`到该VA，然后读取这些pagetable的`PTE_A`并清除即可。

似乎之前的lab并没有说明这些sys函数的参数如何读入，还是模仿其他函数才理解的。这次倒是直接告诉了如何读取地址和整数。。

```c
int sys_pgaccess(void) {
  uint64 address;
  if (argaddr(0, &address) < 0)
    return -1;

  int page_num;
  if (argint(1, &page_num) < 0)
    return -1;

  page_num = page_num > 32 ? 32 : page_num;

  uint64 buffer;
  if (argaddr(2, &buffer) < 0)
    return -1;

  pagetable_t pgtbl = myproc()->pagetable;
  pte_t *pte = walk(pgtbl, (uint64)address, 0);
  int mask = 0;
  for (int i = 0; i < page_num; ++i) {
    if (pte[i] & PTE_A) {
      mask |= 1 << i;
      pte[i] &= ~PTE_A;
    }
  }
  return copyout(pgtbl, buffer, (char *)&mask, sizeof(int));
}
```

